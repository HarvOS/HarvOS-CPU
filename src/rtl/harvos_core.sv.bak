
`include "harvos_pkg_flat.svh"
`include "bus_if.sv"

module harvos_core (
  input  logic clk,
  input  logic rst_n,

  // Harvard buses
  harvos_imem_if.master imem,
  harvos_dmem_if.master dmem,

  // entropy source (optional)
  input  logic        entropy_valid,
  input  logic [31:0] entropy_data,

  // external interrupt (SEIP)
  input  logic        ext_irq,

  // simple MPU programming port (tie off or drive during boot before lock)
  input  logic           mpu_prog_en,
  input  logic [2:0]     mpu_prog_idx,
  input  logic [31:0]    mpu_prog_base,
  input  logic [31:0]    mpu_prog_limit,
  input  logic [2:0]     mpu_prog_perm,  // {x,w,r}
  input  logic           mpu_prog_user_ok,
  input  logic           mpu_prog_is_ispace
);
// removed invalid import *;
  // -----------------
  
  // -----------------
  // Minimal trap path (added)
  // -----------------
  // Latches for a pending synchronous trap and its metadata
  logic        trap_pending_q, trap_pending_d;
  logic [4:0]  trap_scause_q,  trap_scause_d;
  logic [31:0] trap_stval_q,   trap_stval_d;

  // Compute when a trap is actually taken (when IF finishes fetching an instruction and we update PC)
  logic trap_take_now;

  // Default vector (until CSR file is wired)
  localparam logic [31:0] CSR_STVEC_RESET = 32'h00000100;

  // Target PC and SEPC bookkeeping (SEPC exported here if CSR gets wired later)
  logic [31:0] trap_target_pc, sepc_to_write;

  // Fire-and-latch a trap request from anywhere in the core
  task automatic trap_request(input logic [4:0] scause, input logic [31:0] stval);
    trap_pending_d = 1'b1;
    trap_scause_d  = scause;
    trap_stval_d   = stval;
  endtask

  // Trap target computation (simple: vector to stvec)
  trap_unit u_trap_unit (
    .clk            (clk),
    .rst_n          (rst_n),
    .trap_req       (trap_pending_q),
    .trap_scause    (trap_scause_q),
    .trap_stval     (trap_stval_q),
    .cur_pc         (pc_q),
    .csr_stvec_q    (CSR_STVEC_RESET),
    .trap_target_pc (trap_target_pc),
    .sepc_to_write  (sepc_to_write)
  );

  // Trap state registers
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      trap_pending_q <= 1'b0;
      trap_scause_q  <= '0;
      trap_stval_q   <= '0;
    end else begin
      // Clear when we redirect PC to trap_target_pc; otherwise capture new pending requests
      if (trap_take_now) begin
        trap_pending_q <= 1'b0;
      end else if (trap_pending_d) begin
        trap_pending_q <= 1'b1;
      end
      if (trap_pending_d) begin
        trap_scause_q <= trap_scause_d;
        trap_stval_q  <= trap_stval_d;
      end
    end
  end

  // Defaults for the single-cycle "set" inputs to the trap flops
  always_comb begin
    trap_pending_d = 1'b0;
    trap_scause_d  = trap_scause_q;
    trap_stval_d   = trap_stval_q;
  end
// IF/ID/EX/MEM/WB pipeline regs (minimal)
  // -----------------
  logic [31:0] pc_q;
  logic [31:0] if_instr;

  // Register file
  logic        rf_we_wb;
  logic [4:0]  rf_waddr_wb;
  logic [31:0] rf_wdata_wb;
  logic [31:0] rf_rdata1_id, rf_rdata2_id;
  logic [4:0]  rs1_id, rs2_id;

  regfile RF (
    .clk(clk), .rst_n(rst_n),
    .we(rf_we_wb), .waddr(rf_waddr_wb), .wdata(rf_wdata_wb),
    .raddr1(rs1_id), .raddr2(rs2_id), .rdata1(rf_rdata1_id), .rdata2(rf_rdata2_id)
  );

  // Decoder
  logic [31:0] imm_i, imm_s, imm_b, imm_j;
  opcode_e opcode_id;
  logic [2:0] funct3_id;
  logic [6:0] funct7_id;
  logic [4:0] rd_id;
  decoder DEC (
    .instr(if_instr),
    .valid(),
    .opcode(opcode_id),
    .funct3(funct3_id),
    .funct7(funct7_id),
    .rd(rd_id),
    .rs1(rs1_id),
    .rs2(rs2_id),
    .imm_i(imm_i),
    .imm_s(imm_s),
    .imm_b(imm_b),
    .imm_j(imm_j), .imm_u(imm_u)
  );

  // Privilege & core init
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      priv_q <= 2'd3;
      core_dmem_req   <= 1'b0; // deprecated
      core_dmem_we    <= 1'b0;
      core_dmem_be    <= 4'b0000;
      core_dmem_addr  <= 32'h0;
      core_dmem_wdata <= 32'h0;
      // initialize LSU
      lsu_q <= LSU_IDLE;
      ld_pending_q    <= 1'b0;
      ld_pending_rd_q <= 5'd0;
      // defaults
      dc_cpu_req   <= 1'b0;
      dc_cpu_we    <= 1'b0;
      dc_cpu_be    <= 4'h0;
      dc_cpu_addr  <= 32'h0;
      dc_cpu_wdata <= 32'h0;
  end
  end

// Simple 1-entry ALU->store bypass (previous cycle writeback)
  logic last_wb_valid;
  logic [4:0] last_wb_rd;
  logic [31:0] last_wb_data;

  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      last_wb_valid <= 1'b0;
      last_wb_rd    <= 5'd0;
      last_wb_data  <= 32'h0;
    end else begin
      last_wb_valid <= rf_we_wb;
      last_wb_rd    <= rf_waddr_wb;
      last_wb_data  <= rf_wdata_wb;
    end
  end

  // WB path

  // FENCE.I pulse generation
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) icache_flush <= 1'b0;
    else begin
      icache_flush <= (opcode_id == OPC_FENCE) && (funct3_id == 3'b001);
    end
  end

  assign rf_we_wb     = (rd_id != 5'd0) &&
                        (opcode_id == OPC_OP || opcode_id == OPC_OPIMM ||
                         opcode_id == OPC_JAL || opcode_id == OPC_JALR || opcode_id == OPC_LOAD ||
                         (opcode_id == OPC_SYSTEM && (funct3_id != 3'b000)) ||
                         do_entropy_ex);
  assign rf_waddr_wb  = rd_id;
  assign rf_wdata_wb  = (opcode_id == OPC_JAL)  ? pc_q :
                        (opcode_id == OPC_JALR) ? pc_q :
                        (opcode_id == OPC_LOAD) ? (dc_cpu_done ? (
                          (ls_size_ex==LS_W) ? dc_cpu_rdata :
                          (ls_size_ex==LS_H) ? (ls_unsigned_ex ?
                            {16'h0, (dtr_paddr[1] ? dc_cpu_rdata[31:16] : dc_cpu_rdata[15:0])} :
                            {{16{(dtr_paddr[1] ? dc_cpu_rdata[31] : dc_cpu_rdata[15])}},
                              (dtr_paddr[1] ? dc_cpu_rdata[31:16] : dc_cpu_rdata[15:0])}) :
                          /* LS_B */ (ls_unsigned_ex ?
                            {24'h0, (dtr_paddr[1:0]==2'd3 ? dc_cpu_rdata[31:24] :
                                     dtr_paddr[1:0]==2'd2 ? dc_cpu_rdata[23:16] :
                                     dtr_paddr[1:0]==2'd1 ? dc_cpu_rdata[15:8]  :
                                                            dc_cpu_rdata[7:0])} :
                            {{24{(dtr_paddr[1:0]==2'd3 ? dc_cpu_rdata[31] :
                                  dtr_paddr[1:0]==2'd2 ? dc_cpu_rdata[23] :
                                  dtr_paddr[1:0]==2'd1 ? dc_cpu_rdata[15] :
                                                         dc_cpu_rdata[7])}},
                              (dtr_paddr[1:0]==2'd3 ? dc_cpu_rdata[31:24] :
                               dtr_paddr[1:0]==2'd2 ? dc_cpu_rdata[23:16] :
                               dtr_paddr[1:0]==2'd1 ? dc_cpu_rdata[15:8]  :
                                                      dc_cpu_rdata[7:0])})
                        ) : rf_wdata_wb) :
                        (opcode_id == OPC_SYSTEM && (funct3_id != 3'b000)) ? csr_rval_ex :
                        (do_entropy_ex ? (entropy_valid ? entropy_data : 32'h0) : alu_y_ex);// Branch/jump targets
  logic [31:0] branch_target = pc_q + imm_b;
  logic [31:0] jal_target    = pc_q + imm_j;
  logic [31:0] jalr_target   = (rf_rdata1_id + imm_i) & 32'hFFFF_FFFE;

  // IF FSM with MMU + I$
  // I$ cpu-side handshake
  logic ic_cpu_req, ic_cpu_rvalid, ic_cpu_fault;
  logic [31:0] ic_cpu_rdata;
  // I$ instance (physical addressing)
  icache_lock IC (
    .clk, .rst_n,
    .cpu_req(ic_cpu_req), .cpu_addr(if_paddr), .mpu_exec_allow(mpu_allow_if), .cpu_rdata(ic_cpu_rdata), .cpu_rvalid(ic_cpu_rvalid), .cpu_fault(ic_cpu_fault),
    .mem(imem),
    .lock_we(1'b0), .lock_index('0), .lock_set(1'b0),
    .flush_all(icache_flush),
    .stat_hits(), .stat_misses()
  );

  // IF FSM with MMU
  typedef enum logic [1:0] {IF_IDLE, IF_TLB, IF_REQ, IF_WAIT} if_state_e;
  if_state_e if_state_q;
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      core_dmem_req   <= 1'b0; // deprecated
      core_dmem_we    <= 1'b0;
      core_dmem_be    <= 4'b0000;
      core_dmem_addr  <= 32'h0;
      core_dmem_wdata <= 32'h0;
      // initialize lsu
      lsu_q <= LSU_IDLE;
      ld_pending_q <= 1'b0;
      ld_pending_rd_q <= 5'd0;
      dc_cpu_req <= 1'b0; dc_cpu_we <= 1'b0; dc_cpu_be <= 4'h0; dc_cpu_addr <= 32'h0; dc_cpu_wdata <= 32'h0;
    end else begin
      // default
      dc_cpu_req <= 1'b0;
      lsu_q <= lsu_n;

      unique case (lsu_q)
        LSU_IDLE: begin
          if (do_load_ex || do_store_ex) begin
            if (!dtr_ready) begin
              lsu_n = LSU_IDLE; // wait for translation
            end else if (dtr_fault) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !dtr_perm_r) || (do_store_ex && !dtr_perm_w)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && mpu_is_ispace_ld) || (do_store_ex && mpu_is_ispace_st)) begin
              trap_request(SCAUSE_HARVARD_VIOLATION, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !mpu_allow_ld) || (do_store_ex && !mpu_allow_st)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else begin
              // issue to D$
              dc_cpu_req   <= 1'b1;
              dc_cpu_we    <= do_store_ex;
              dc_cpu_be    <= (ls_size_ex==LS_W) ? 4'b1111 : (ls_size_ex==LS_H ? (4'b0011 << dtr_paddr[1]) : (4'b0001 << dtr_paddr[1:0]));
              dc_cpu_addr  <= dtr_paddr & 32'hFFFF_FFFC;
              dc_cpu_wdata <= (last_wb_valid && (last_wb_rd == rs2_id) && (last_wb_rd != 5'd0)) ? last_wb_data : rf_rdata2_id;
              // scoreboard if load
              if (do_load_ex && (rd_id != 5'd0)) begin
                ld_pending_q    <= 1'b1;
                ld_pending_rd_q <= rd_id;
              end
              lsu_n = LSU_WAIT;
            end
          end
        end
        LSU_WAIT: begin
          if (dc_cpu_done) begin
            lsu_n = LSU_IDLE;
          end
        end
        default: lsu_n = LSU_IDLE;
      endcase
    end
  end
  // IF FSM (wrapped in its own always_ff)
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      ic_cpu_req <= 1'b0;
      if_req     <= 1'b0;
      if_state_q <= IF_IDLE;
    end else begin
      unique case (if_state_q)
        IF_TLB: begin
          if (if_ready) begin
            if_req <= 1'b0;
            if (if_fault || !if_perm_x || !mpu_allow_if) begin
              trap_request(SCAUSE_INST_ACCESS_FAULT, pc_q);
              if_state_q <= IF_IDLE;
            end else begin
              ic_cpu_req <= 1'b1; // via I$
              // address to I$ is if_paddr (wired into icache_lock)
              if_state_q <= IF_REQ;
            end
          end
        end
        IF_REQ: begin
          ic_cpu_req <= 1'b0; // one-cycle pulse
          if_state_q <= IF_WAIT;
        end
        IF_WAIT: begin
          if (ic_cpu_rvalid) begin
            if (ic_cpu_fault) begin
              trap_request(SCAUSE_INST_ACCESS_FAULT, pc_q);
            end else begin
              if_instr <= ic_cpu_rdata;
              if (trap_pending_q) begin pc_q <= trap_target_pc; end else begin pc_q     <= pc_q + 32'd4; end // default advance
            end
            if_state_q <= IF_IDLE;
          end
        end
        default: ; // IF_IDLE and others do nothing here
      endcase
    end
  end


  
  // trap_take_now is true exactly when IF updates PC to the trap vector
  always_comb begin
    trap_take_now = (if_state_q == IF_WAIT) && ic_cpu_rvalid && !ic_cpu_fault && trap_pending_q;
  end
// Data translation request signals
  always_comb begin
    dtr_req = 1'b0;
    dtr_acc = ACC_LOAD;
    if (do_load_ex)  begin dtr_req = 1'b1; dtr_acc = ACC_LOAD; end
    if (do_store_ex) begin dtr_req = 1'b1; dtr_acc = ACC_STORE; end
  end

  // Core's own D-mem master port (to arbiter)
  logic        dc_cpu_req, dc_cpu_we;
  logic [3:0]  dc_cpu_be;
  logic [31:0] dc_cpu_addr, dc_cpu_wdata, dc_cpu_rdata;
  logic        dc_cpu_rvalid, dc_cpu_fault;

  // D$ cpu-side wires (line-based, multi-cycle)
  typedef enum logic [1:0] {LSU_IDLE, LSU_ISSUE, LSU_WAIT} lsu_e;
  lsu_e lsu_q, lsu_n;
  logic        dc_cpu_req, dc_cpu_we;
  logic [3:0] dc_cpu_be;
  logic [31:0] dc_cpu_addr, dc_cpu_wdata, dc_cpu_rdata;
  logic        dc_cpu_done, dc_cpu_fault;

  // Register scoreboard for pending LOAD (simple 1-entry)
  logic        ld_pending_q;
  logic [4:0]  ld_pending_rd_q;

  // D$ memory-side wires to arbiter m0
  logic        m0_req, m0_we;
  logic [3:0] m0_be;
  logic [31:0] m0_addr, m0_wdata, m0_rdata;
  logic m0_rvalid, m0_fault;

  dcache_2way DC (
    .clk, .rst_n,
    .cpu_req(dc_cpu_req), .cpu_we(dc_cpu_we), .cpu_be(dc_cpu_be), .cpu_addr(dc_cpu_addr), .cpu_wdata(dc_cpu_wdata),
    .cpu_rdata(dc_cpu_rdata), .cpu_done(dc_cpu_done), .cpu_fault(dc_cpu_fault),
    .mem_req(m0_req), .mem_we(m0_we), .mem_be(m0_be), .mem_addr(m0_addr), .mem_wdata(m0_wdata),
    .mem_rdata(m0_rdata), .mem_rvalid(m0_rvalid), .mem_fault(m0_fault),
    .stat_hits(), .stat_misses()
  );

  // Global stall when LSU is busy or when load-use hazard exists
  logic ld_use_hazard = ld_pending_q && ((rs1_id == ld_pending_rd_q) || (rs2_id == ld_pending_rd_q)) && (ld_pending_rd_q != 5'd0);
  logic stall_global  = (lsu_q != LSU_IDLE) || ld_use_hazard;
  
  // Arbiter instance
  
  dmem_arbiter DMEM_ARB (
    .clk, .rst_n,
    // m0: core
    .m0_req(m0_req), .m0_we(m0_we), .m0_be(m0_be),
    .m0_addr(m0_addr), .m0_wdata(m0_wdata),
    .m0_rdata(m0_rdata), .m0_rvalid(m0_rvalid), .m0_fault(m0_fault),
    // m1: PTW
    .m1_req(ptw_req), .m1_addr(ptw_addr), .m1_rdata(ptw_rdata), .m1_rvalid(ptw_rvalid), .m1_fault(ptw_fault),
    // external
    .dmem(dmem)
  );

  // MEM stage with MMU/MPU checks
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      core_dmem_req   <= 1'b0; // deprecated
      core_dmem_we    <= 1'b0;
      core_dmem_be    <= 4'b0000;
      core_dmem_addr  <= 32'h0;
      core_dmem_wdata <= 32'h0;
      // initialize lsu
      lsu_q <= LSU_IDLE;
      ld_pending_q <= 1'b0;
      ld_pending_rd_q <= 5'd0;
      dc_cpu_req <= 1'b0; dc_cpu_we <= 1'b0; dc_cpu_be <= 4'h0; dc_cpu_addr <= 32'h0; dc_cpu_wdata <= 32'h0;
    end else begin
      // default
      dc_cpu_req <= 1'b0;
      lsu_q <= lsu_n;

      unique case (lsu_q)
        LSU_IDLE: begin
          if (do_load_ex || do_store_ex) begin
            if (!dtr_ready) begin
              lsu_n = LSU_IDLE; // wait for translation
            end else if (dtr_fault) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !dtr_perm_r) || (do_store_ex && !dtr_perm_w)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && mpu_is_ispace_ld) || (do_store_ex && mpu_is_ispace_st)) begin
              trap_request(SCAUSE_HARVARD_VIOLATION, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !mpu_allow_ld) || (do_store_ex && !mpu_allow_st)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else begin
              // issue to D$
              dc_cpu_req   <= 1'b1;
              dc_cpu_we    <= do_store_ex;
              dc_cpu_be    <= (ls_size_ex==LS_W) ? 4'b1111 : (ls_size_ex==LS_H ? (4'b0011 << dtr_paddr[1]) : (4'b0001 << dtr_paddr[1:0]));
              dc_cpu_addr  <= dtr_paddr & 32'hFFFF_FFFC;
              dc_cpu_wdata <= (last_wb_valid && (last_wb_rd == rs2_id) && (last_wb_rd != 5'd0)) ? last_wb_data : rf_rdata2_id;
              // scoreboard if load
              if (do_load_ex && (rd_id != 5'd0)) begin
                ld_pending_q    <= 1'b1;
                ld_pending_rd_q <= rd_id;
              end
              lsu_n = LSU_WAIT;
            end
          end
        end
        LSU_WAIT: begin
          if (dc_cpu_done) begin
            lsu_n = LSU_IDLE;
          end
        end
        default: lsu_n = LSU_IDLE;
      endcase
  end
end
  // Control flow & traps
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      core_dmem_req   <= 1'b0; // deprecated
      core_dmem_we    <= 1'b0;
      core_dmem_be    <= 4'b0000;
      core_dmem_addr  <= 32'h0;
      core_dmem_wdata <= 32'h0;
      // initialize lsu
      lsu_q <= LSU_IDLE;
      ld_pending_q <= 1'b0;
      ld_pending_rd_q <= 5'd0;
      dc_cpu_req <= 1'b0; dc_cpu_we <= 1'b0; dc_cpu_be <= 4'h0; dc_cpu_addr <= 32'h0; dc_cpu_wdata <= 32'h0;
    end else begin
      // default
      dc_cpu_req <= 1'b0;
      lsu_q <= lsu_n;

      unique case (lsu_q)
        LSU_IDLE: begin
          if (do_load_ex || do_store_ex) begin
            if (!dtr_ready) begin
              lsu_n = LSU_IDLE; // wait for translation
            end else if (dtr_fault) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !dtr_perm_r) || (do_store_ex && !dtr_perm_w)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, alu_y_ex);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && mpu_is_ispace_ld) || (do_store_ex && mpu_is_ispace_st)) begin
              trap_request(SCAUSE_HARVARD_VIOLATION, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else if ((do_load_ex && !mpu_allow_ld) || (do_store_ex && !mpu_allow_st)) begin
              trap_request((do_load_ex)?SCAUSE_LOAD_ACCESS_FAULT:SCAUSE_STORE_ACCESS_FAULT, dtr_paddr);
              lsu_n = LSU_IDLE;
            end else begin
              // issue to D$
              dc_cpu_req   <= 1'b1;
              dc_cpu_we    <= do_store_ex;
              dc_cpu_be    <= (ls_size_ex==LS_W) ? 4'b1111 : (ls_size_ex==LS_H ? (4'b0011 << dtr_paddr[1]) : (4'b0001 << dtr_paddr[1:0]));
              dc_cpu_addr  <= dtr_paddr & 32'hFFFF_FFFC;
              dc_cpu_wdata <= (last_wb_valid && (last_wb_rd == rs2_id) && (last_wb_rd != 5'd0)) ? last_wb_data : rf_rdata2_id;
              // scoreboard if load
              if (do_load_ex && (rd_id != 5'd0)) begin
                ld_pending_q    <= 1'b1;
                ld_pending_rd_q <= rd_id;
              end
              lsu_n = LSU_WAIT;
            end
          end
        end
        LSU_WAIT: begin
          if (dc_cpu_done) begin
            lsu_n = LSU_IDLE;
          end
        end
        default: lsu_n = LSU_IDLE;
      endcase
    end
  end

endmodule // harvos_core (closed)
